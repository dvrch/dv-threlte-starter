<script lang="ts">
	import Bibigame from './bibigame.svelte';
  import { onMount } from 'svelte';
  import { writable } from 'svelte/store'; // Correction de l'import
  import Nissangame from './nissangame.svelte';
  import Garden from './models/garden.svelte'; 
  import { T } from '@threlte/core';
  import { ContactShadows, Float, Grid, OrbitControls } from '@threlte/extras';
  // import { page } from '$app/stores';
  import Bloom from './models/bloom.svelte';
  import { useGltf } from '@threlte/extras';
  import Nissan from './models/Nissan.svelte';
  import AddGeometry from './AddGeometry.svelte'; // Importation du composant
  
  import Tissus from '../bibi/tissus-simulat.svelte';
  import Bibanime from '../bibi/bibanime.svelte';
  import Vague from '../vague/+page.svelte';
  import Spaceship from '../Spaceship/+page.svelte';
  import Desk from '../desksc/+page.svelte';
  
  type Position = {
    x: number;
    y: number;
    z: number;
  };

  type Geometry = {
    id: string;
    position: Position;
    rotation: Position;
    type: string;
    color: string;
    name: string;
  };

  // Mise à jour des props de Bibanime
  interface BibanimeProps {
    position: [number, number, number];
    scale: number;
  }

  let geometries: Geometry[] = [];

  // Créer un store pour la géométrie sélectionnée
  const selectedGeometry = writable<Geometry | null>(null);

  const handleGeometryClick = (geometry: Geometry) => {
    $selectedGeometry = geometry; // Mettre à jour le store
  };

  const handleDelete = () => {
    if ($selectedGeometry) {
      deleteGeometry($selectedGeometry.id);
      $selectedGeometry = null; // Réinitialiser la sélection
    }
  };

  const deleteGeometry = async (id: string) => {
    try {
      const response = await fetch(`http://localhost:8000/api/geometries/${id}/`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete geometry');
      }

      loadGeometries();

      

      // Mettre à jour la liste des géométries après la suppression
      geometries = geometries.filter(geometry => geometry.id !== id);
      alert('Geometry deleted successfully!');
    } catch (error) {
      console.error('Error deleting geometry:', error);
      alert('Failed to delete geometry. Please try again.');
    }
  };

  const loadGeometries = async () => {
    try {
      const response = await fetch('http://localhost:8000/api/geometries/');
      if (!response.ok) {
        throw new Error('Failed to fetch geometries');
      }
      geometries = await response.json();
      console.log('Loaded geometries:', geometries);
    } catch (error) {
      console.error('Error loading geometries:', error);
    }
  };

  // Charger les géométries au montage
  onMount(() => {
    loadGeometries();
  });

  // Fonction pour gérer les changements de géométrie
  const handleGeometryChange = () => {
    loadGeometries();
    $selectedGeometry = null; // Réinitialiser la sélection après une modification
  };
</script>  



<T.PerspectiveCamera makeDefault position={[-10, 10, 10]} fov={70} aspect={window.innerWidth * 0.3 / window.innerHeight * 0.3}>
  <!-- AVEC ZOOM et max/min distance -->
  <OrbitControls autoRotate enableZoom={true} minDistance={0} maxDistance={80} target={[0, 1.5, 0]} />
</T.PerspectiveCamera>

<T.DirectionalLight intensity={0.8} position={[5, 10, 0]} />
<T.AmbientLight intensity={0.2} />

<Grid position={[0, -0.001, 0]} cellColor="#ffffff" sectionColor="#ffffff" sectionThickness={0} fadeDistance={25} cellSize={2} />

<ContactShadows scale={10} blur={2} far={2.5} opacity={0.5} />

<Bloom />

<AddGeometry 
  selectedGeometry={$selectedGeometry} 
  on:geometryChanged={handleGeometryChange} 
/>

{#each geometries as geometry (geometry.id)}
  <Float 
    floatIntensity={1} 
    floatingRange={[0, 1]} 
    on:click={() => handleGeometryClick(geometry)}
  >
    
    {#if geometry.type === 'box'}
      <T.Mesh position={[geometry.position.x, geometry.position.y, geometry.position.z]} 
      rotation={[geometry.rotation.x, geometry.rotation.y, geometry.rotation.z]} scale={0.5}>
        <T.BoxGeometry />
        <T.MeshStandardMaterial color={geometry.color} />
      </T.Mesh>
    {:else if geometry.type === 'torus'}
      <T.Mesh position={[geometry.position.x, geometry.position.y, geometry.position.z]} 
      rotation={[geometry.rotation.x, geometry.rotation.y, geometry.rotation.z]} scale={0.5}>
        <T.TorusKnotGeometry args={[0.5, 0.15, 100, 12, 2, 3]} />
        <T.MeshStandardMaterial color={geometry.color} />
      </T.Mesh>
    {:else if geometry.type === 'icosahedron'}
      <T.Mesh position={[geometry.position.x, geometry.position.y, geometry.position.z]} 
      rotation={[geometry.rotation.x, geometry.rotation.y, geometry.rotation.z]} scale={0.5}>
        <T.IcosahedronGeometry />
        <T.MeshStandardMaterial color={geometry.color} />
      </T.Mesh>
    {:else if geometry.type === 'nissangame'}
      <Nissangame />
    {:else if geometry.type === 'garden'}
      <Garden />
      {#await useGltf('/assets/garden.glb') then ghost}
      <T is={ghost.scene} position={[0, 0, 0]} scale={0.4} />
      {/await}
      {:else if geometry.type === 'nissan'}
      <Garden />
      {#await useGltf('/assets/nissan.glb') then ghost}
      <T is={ghost.scene} position={[0, 0, 0]} scale={0.4} />
      {/await}
    {:else if geometry.type === 'bibi'}
      <Bibanime 
        position={[geometry.position.x, geometry.position.y, geometry.position.z]} 
        scale={5} 
      />
    {:else if geometry.type === 'tissus'}
      <Tissus 
        position={[geometry.position.x, geometry.position.y, geometry.position.z]} 
        scale={5} 
      />
    {:else if geometry.type === 'vague'}
      {console.log('Vague position:', [geometry.position.x, geometry.position.y, geometry.position.z])}
      <Vague 
        position={[geometry.position.x, geometry.position.y, geometry.position.z]} 
        rotation={[geometry.rotation.x, geometry.rotation.y, geometry.rotation.z]}
        scale={5}
      />
      {:else if geometry.type === 'desk'}
      {console.log('Desk position:', [geometry.position.x, geometry.position.y, geometry.position.z])}
      <Desk 
        position={[geometry.position.x, geometry.position.y, geometry.position.z]} 
        rotation={[geometry.rotation.x, geometry.rotation.y, geometry.rotation.z]}
        scale={5}
      />
    {:else if geometry.type === 'sphere'}
      <Spaceship 
        position={[geometry.position.x, geometry.position.y, geometry.position.z]} 
        rotation={[geometry.rotation.x, geometry.rotation.y, geometry.rotation.z]}
        scale={5}
      />
      {:else if geometry.type === 'bibigame'}
      <Bibigame />
    {/if}
  </Float>
  
{/each}

 


